### 멀티스레드와 JVM
자바에서는 프로세스가 존재하지 않고 스레드 개념만 존재혐, JVM은 멀티스레딩만 지원한다.
자바스레드는 JVM에 의해 스케쥴되는 실행단위 코드블록이다.
하나의 JVM은 하나의 자바 응용프로그램만 실행한다. 사용자가 자바 응용프로그램을 실행시키면, JVM이 먼저 실행되고
JVM이 자바 응용프로그램을 로딩하여 실행시킨다. 자바 응용프로그램이 종료되면 JVM도 함께 종료된다.
만일 한 컴퓨터에서 n개의 자바 응용프로그램이 실행된다고하면 n개의 JVM이 실행되고 있는 것이다.
> 이들은 각 별개의 메모리 영역에서 독립적으로 실행된다.

![image](https://user-images.githubusercontent.com/80390524/131290673-fc9470e5-4f52-4351-93ea-f50e06ad54f8.png)

2개이상의 자바 응용프로그램을 실행하고자 하는경우 각가 JVM에서 실행하며 서로 정보를 주고 받고자 하는 경우
소켓통신과같은 통신방법을 이용한다.


### 자바스레드와JVM
자바스레드는 다른 운영체제의 스레드와 크게 다르지 않다.
스레드를 만들기위해 실행될 프로그램코드를 작성해야하는데 이 코드를 JVM에 등록하기만 하면된다.
그후 스레드 코드를 시행시키고 잠깐 중단시키기도 하는등 스레드 스케쥴링은 전적으로 JVM에 의해 이루어진다.




### 스레드 생성

1) thread클래스 상속

우선 thread클래스를 상속받아서 run()메소드를 오버라이딩한다.
run()메소드에 작성된코드를 스레드코드라고 부르는데 스레드는 run()에서부터 실행을 시작하고 run()이 종료되면 스레드도 종료된다.
만일 run()을 오버라이딩을 하지 않으면 thread클래스에 작성된 run()이 실행되며 아무일도하지않고 바로 종료된다.

이제 스레드 객체를 생성하면 되는데 스레드 객체를 생성한는것은그저 객체생성일 뿐이다.
스레드는 다른 객체와달리 JVM에 등록되어 JVM에의해 스케쥴링되어야 비로소 작동되는 것이다.



이 생성한 객체를 start()메소드를 호출하여 스레드를 동작시킨다.
start()는 생성된 스레드객체를 스케쥴링이 가능한 사애로 전환하도록 JVM에게 지시한다. 이후 스케쥴링에 의해
이 스레드가 선택되면 비로소 JVM에 의해 run()메소드가 호출되어 실행을 시작한다.



2) Runnable 인터페이스로 스레드 만들기

Runnable은클래스가 아닌 인터페이스로서 추상메소드 run()하나만 가지고 있다.
Runnable을 implements를 한후 run()메소드를 오버라이딩하면된다.
이후 Thread객체를 생성한수 생성자에 적용할 클래스를 전달하면 된다.
```java
Thread th=new Thread(new TimerRunnable());
```
이후 start()메소드를 호출하여 스레드를 시작하면 된다.


![image](https://user-images.githubusercontent.com/80390524/131481642-8edbcc84-a465-4662-b58e-f35123aacbc8.png)


### 데몬스레드

자바의 스레드느 두가지 종류로 구분된다.
첫째는 데몬스레드인데 응용프로그램이 실해오디는 동안 관리를 위해 존재하는 스레드로, 가비지 컬렉션 스레드가 대표적이다.

두번째는 사용자스레드로서 응용프로그램에서 생성한 스레드이다.
main()메소드를 실행하는 maint()스레드역시 사용자 스레드이다. 
> 사용자 스레드는 Thread클래스의 setDaemon(true)를 호출하면 데몬스레드로 바꿀 수 있다.

데몬스레드가 사용자 스레드와 다른점은 데본스레드가 살아있더라도 사용자 스레드가 모두 종료하면 JVM과함께 응용프로그램도 종료된다.


### 스레드 상태

![image](https://user-images.githubusercontent.com/80390524/131482120-41bea0d0-7162-4426-9768-5da3ab7acb1b.png)

* NEW
스레드가 생성되었지만 아직 실행할 준비가 되지 않은 상태이다.
start()메소드가 호출되면 RUNNABLE상태가 된다.

* RUNNABLE
스레드가 현재 실행되고 있거나, 실행 준비되어 스케쥴링을 기다리는 상태이다.

* TIMED_WAITING
스레드가 sleep을 호출하여 n밀리초동안 잠을 자는 상태이다.

* BLOCK
스레드가I/O작업을 실행하여 I/O작업의 완료를 기다리면서 멈푼 상태이다.
스레드가 I/O작업을 실행하면 JVM이 자동으로 현재 스레드를 BLOCK상태로 만들고 다른 스레드를 스케쥴링한다.

* WAITING
스레드가 어떤 객체 a에 대해 a.wait()를 호출하여 다른 스레드가 a.notify(),a.notifyAll()을 불러줄때까지 무한정 기다리는 상태이다.

* TERMINATED
스레드가 종료한 상태이다.


### 스레드의 일생

new Thread()에 의해 스레드 객체가 생성되면 JVM은생성된 스레드 정보를 관리한다. 생성된 스레드는 NEW상태이다. NEW상태의 스레드는 스케쥴링 되지 않기 때문에
실행될수 없는 상태이다.
> 스케쥴링이란 JVM이 RUNNABLE상태인스레드 중에서 하나를 선택하여 실행시키는 과정이다.

스레드 클래스의 start()메소드가 호출되면, 스레드는 비로소 실행될 수 있는 RUNNABLE상태가 된다. JVM은 RUNNABLE상태에 있는
스레드중에서 하나를 선택하고 실행시킨다. 처음으로 스케줄링되는 스레드는 run()메소드의 첫 라인부터 실행은 시작한다.

우선 실행중인 스레드가 I/O작업을 하게되면 JVM에서 즉각 중지되며 BLOCK상태가 된다. BLOCK상태의 스레드는 I/O작업이 완료될때까지
스케줄링되지 않고 대기하며 완료되면 RUNNABLE상태가 된다.

실행중인 스레드가 종료하면 TERMINATED상태가되며, 더이상 RUNNABLE상태로 돌아올 수 없다.


실행중인 스레드가 어떤 객체 a의 wait()메소드를 호출하여 다른 스레드로부터 깨워지기를 기다리는 경우를 가정해보자.
이때 객체a를 동기화 객체라고 부른다. 모든 객체는 java.lang.Object를 상속받으며 wait()메소드는 java.lang.Object클래스의 멤버이므로
모든 객체가 동기화 객체가 될수 있다.
첫번째 스레드가 객체 a의 a.wait()를 호출하여 기다리고 있을때, 다른 스레드가 a.notify()나 a.notifyAll()메소드를 호출하게되면
첫번째 스레드는 깨어나서 RUNNABLE상태로 돌아가게 된다.


### 우선순위
JVM은 우선순위를 기반으로 스레드를 스케쥴링한다.
우선순위가 높은 순으로 스레드를 실행시킨다. 동일한 우선순위인 경우에는 돌아가며 실행시킨다.
> 최댓값은 10, 최저는 0이며, 보통은 5이다.

> 프로그램이 실행될때 처음으로 생성되는 main스레드는 보통값의 우선순위로 태어난다.

> 자식 스레드는 생성될때 부모 스레드의 우선순위 값을 물려받는다.

>setPriority()로 우선순위값을 바꿀 수 있다.


### main스레드
JVM은 자바 응용프로그램을 실행하기 직전, 사용자 스레드를 하나 만들고, 이 스레드로 하여금 main()메소드를 실행하도록 한다.
이 스레드가 메인스레드이고 실행시작 주소는 main()메소드의 첫 코드가 된다.
> 즉, 프로그램이 실행하면 2개의 스레드가 존재하는 셈이다.




### flag를 이용한 종료

```java
if(flag==true) {
					contentPane.removeAll();
					label=new JLabel("finish");
					label.setSize(80, 30);
					label.setLocation(100, 100);
					
					label.setForeground(Color.RED);
					contentPane.add(label);
					contentPane.repaint();
					return;
				}
```

필드에 boolean flag필드와 finish()메소드를 추가하여 finish()메소드를 호출하면 flag값을 true로 바꾸게하여
스레드를 종료시키도록 한것이다.










