### 쿼리메소드

* 쿼리메소드의 기능

1. 메소드 이름으로 쿼리 생성
  만약 이름과 나이로 회원을 조회한다면 다음과 같이 메소드 이름을 조회한다.
  > List(Membe)findByUsernameAndAge(String userName,int age);
  
  인터페이스에 정의한 findByUsernameAndAge()메소드를 실행하면 스프링데이터 JPA는 메소드 이름을 분석하여 JPQL을 생성하고 실행한다.
  
2. JPA NmedQuery
  스프링 데이터 JPA는 메소드 이름으로 JPA Named쿼리를 호출하는 기능을 제공한다.
  
 
  
  쿼리메소드에는return타입을 고정해서 사용하는것이 아니라, return타입에 맞추어 return시킨다.
  
  메소드 이름을 정할때는 여러 키워드들이 있으니 상황에 맞추어 활용하면 된다.
  
```java
List<User> findByName(String name);

    User findByEmail(String email);

    User getByEmail(String email);

    User readByEmail(String email);

    User queryByEmail(String email);

    User searchByEmail(String email);

    User streamByEmail(String email);

    User findUserByEmail(String email);
```

```java
System.out.println("findByEmailAndName:"+userRepository.findByEmailAndName("kr@naver.com","martin"));
System.out.println("findByEmailOrName:"+userRepository.findByEmailOrName("kr@naver.com","martin"));
```
> where조건을 사용하여 조건을 검색한다.


모두같은 동작을 하므로 가독성이 제일 높은것을 사용하면 된다.
뒤에 First,Top과 같이 접두에 연결하여 사용할 수 도있다.

> 둘다 같은 기능으로 First1/Top1과같이 사용한다.

> 중복된 ID를 가진 쿼리가 있으면 1번째 것을 가져온다.

> 위의Find,get...도 그렇고 이것도 그렇고 단지 네이밍의 차이이다. 요즘 추세가 가독성이 높은 코드이다보니 상황에 맞는 이름을 사용하면 되겠다.



AND
```java
    List<User>findByEmailAndName(String email,String name);
```
Email과 Name을 둘다 만족시키는 쿼리를 return한다. 로그를 확인하면
where조건에 email and name이 들어있다.

OR도 사용하는방법은 마찬가지이며 용도는 익히아는 OR이다.


After/Before
```java
    List<User>findByCreatedAtAfter(LocalDateTime yesterday);
```

시간에 대한조건이다.
인자로 now()를 받을 수 있다.
After는 특정 날짜보다 큰것, Before는 작은것을 가져온다.

추가로 사실 시간에만 사용한다기 보다는 크기비교로 사용할 수 도 있다.
하지만 Naming문제가 있기 때문에 before/after를 사용하기 보다는 GreaterThan/Greater/Less/Lessthen/equal를 사용하여 크기비교를 한다.

