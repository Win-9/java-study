### 쿼리메소드

* 쿼리메소드의 기능

1. 메소드 이름으로 쿼리 생성
  만약 이름과 나이로 회원을 조회한다면 다음과 같이 메소드 이름을 조회한다.
  > List(Membe)findByUsernameAndAge(String userName,int age);
  
  인터페이스에 정의한 findByUsernameAndAge()메소드를 실행하면 스프링데이터 JPA는 메소드 이름을 분석하여 JPQL을 생성하고 실행한다.
  
2. JPA NmedQuery
  스프링 데이터 JPA는 메소드 이름으로 JPA Named쿼리를 호출하는 기능을 제공한다.
  
 
  
  쿼리메소드에는return타입을 고정해서 사용하는것이 아니라, return타입에 맞추어 return시킨다.
  
  메소드 이름을 정할때는 여러 키워드들이 있으니 상황에 맞추어 활용하면 된다.
  
```java
List<User> findByName(String name);

    User findByEmail(String email);

    User getByEmail(String email);

    User readByEmail(String email);

    User queryByEmail(String email);

    User searchByEmail(String email);

    User streamByEmail(String email);

    User findUserByEmail(String email);
```

```java
System.out.println("findByEmailAndName:"+userRepository.findByEmailAndName("kr@naver.com","martin"));
System.out.println("findByEmailOrName:"+userRepository.findByEmailOrName("kr@naver.com","martin"));
```
> where조건을 사용하여 조건을 검색한다.


모두같은 동작을 하므로 가독성이 제일 높은것을 사용하면 된다.
뒤에 First,Top과 같이 접두에 연결하여 사용할 수 도있다.

> 둘다 같은 기능으로 First1/Top1과같이 사용한다.

> 중복된 ID를 가진 쿼리가 있으면 1번째 것을 가져온다.

> 위의Find,get...도 그렇고 이것도 그렇고 단지 네이밍의 차이이다. 요즘 추세가 가독성이 높은 코드이다보니 상황에 맞는 이름을 사용하면 되겠다.



AND
```java
    List<User>findByEmailAndName(String email,String name);
```
Email과 Name을 둘다 만족시키는 쿼리를 return한다. 로그를 확인하면
where조건에 email and name이 들어있다.

OR도 사용하는방법은 마찬가지이며 용도는 익히아는 OR이다.


After/Before
```java
    List<User>findByCreatedAtAfter(LocalDateTime yesterday);
```

시간에 대한조건이다.
인자로 now()를 받을 수 있다.
After는 특정 날짜보다 큰것, Before는 작은것을 가져온다.

추가로 사실 시간에만 사용한다기 보다는 크기비교로 사용할 수 도 있다.
하지만 Naming문제가 있기 때문에 before/after를 사용하기 보다는 GreaterThan/Greater/Less/Lessthen/equal를 사용하여 크기비교를 한다.




### Empty값에대한 조회

![Screenshot_20210821-211304_Chrome](https://user-images.githubusercontent.com/80390524/130321478-d8489cb2-1810-4d46-899f-6c72a0262cf1.jpg)


find By Id Is Not Null

> where 편에 is not null 이 추가된다.

Is Not Empty 의 경우 오류가 생긴다.

> Not 때이면서 Not Empty 를 체크하는 것은
> 일반적으로 Not Empty 이기 때문 (문자열의 empty:"")
> 여기서는 (collection 타입의 Empty를 체크하게 된다.


### in

```java
List<User>findByNameIn(List<String>names);
```

매개변수의 에는 iterator타입인 list가 들어가고, list 타입은 names의 타입이 들어간다.


값을 list 로 받게 되는데 일반적으로 다른 쿼리의 결과 값을 넣는다.
얼마나 많은 데이터가 들어갈지 확인이 안되기 때문에 list 길이가
길어지게 되면 성능 적인 이슈가 발생할 수 있다.


### StartingWith/EdningWith/Contains

가각 문자열에 대한 쿼리 like로 실행된다.
> like는 sql에서 문자열 검색에 사용된다.

> StartingWith/EndingWith는 사실 네이밍 이슈때문에 구분되어진 것이다.

> %like를 하게되면 Staring이고 like%를 사용하게 되면 EndingWith이다.



